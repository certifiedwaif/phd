.9, 1, .9,
.9, .9, 1), 3, 3)
mSigma <- as.matrix(bdiag(mSigma_block, mSigma_block, mSigma_block,
mSigma_block))
chol_mSigma <- chol(mSigma)
for (i in 1:n) {
mX[i, ] <- t(chol_mSigma) %*% rnorm(p)
}
vy <- 1.3 * mX[, 1] + 13 * mX[, 4] + 1.3 * mX[, 7] + 1.3 * mX[, 10] + rnorm(n, 0., sigma2)
mX <- scale(mX)
vy <- (vy - mean(vy))
vy <- sqrt(n) * vy / sqrt(sum(vy ^ 2))
K <- 1e3
initial_gamma <- matrix(rbinom(K * p, 1, .5), K, p)
return(list(n=n, p=p, vy=vy, mX=mX, K=K, initial_gamma=initial_gamma))
}
data <- generate_data()
n <- data$n
p <- data$p
vy <- data$vy
mX <- data$mX
K <- data$K
initial_gamma <- data$initial_gamma
cva_result <- cva(initial_gamma, vy, mX, K)
corr_result <- correlation::all_correlations_mX(vy, mX)
binary_to_model <- function(binary_vec)
{
acc <- 0
mul <- 1
for (i in 1:length(binary_vec)) {
acc <- acc + mul * binary_vec[i]
mul <- mul * 2
}
return(acc)
}
log_p <- function(n, p, vR2, vp_gamma)
{
R2 <- R2[2:length(R2)]
p_gamma <- p_gamma[2:length(p_gamma)]
a <- 1
b <- p
return(-n / 2 * log(1 - R2) - p_gamma / 2 * log(n) + lbeta(a + p_gamma, b + p - p_gamma))
}
R2 <- corr_result$vR2
p_gamma <- corr_result$vp_gamma
cva_models <- apply(cva_result$models, 1, binary_to_model)
plot(log_p(n, p, R2, p_gamma), pch=21, xlab="Model Index", ylab="Posterior Model Probability", col="black", bg="black")
points(cva_models, log_p(n, p, R2, p_gamma)[cva_models], pch=21, col="red", bg="red")
plot_traj_probs <- function(cva_result)
{
traj_prob <- log(cva_result$trajectory_probs)
plot(1:ncol(traj_prob), traj_prob[1, ], ylim=c(min(traj_prob), max(traj_prob)), type="l",
xlab="Iteration", ylab="Posterior Probability")
for (k in 1:nrow(traj_prob)) {
lines(1:ncol(traj_prob), traj_prob[k, ])
}
}
plot_traj_probs(cva_result)
set.seed(as.numeric(Sys.time()))
generate_data <- function()
{
n <- 50
p <- 12
sigma2 <- 1.
mX <- matrix(0, n, p)
mSigma_block <- matrix(c(1, .9, .9,
.9, 1, .9,
.9, .9, 1), 3, 3)
mSigma <- as.matrix(bdiag(mSigma_block, mSigma_block, mSigma_block,
mSigma_block))
chol_mSigma <- chol(mSigma)
for (i in 1:n) {
mX[i, ] <- t(chol_mSigma) %*% rnorm(p)
}
vy <- 1.3 * mX[, 1] + 13 * mX[, 4] + 1.3 * mX[, 7] + 1.3 * mX[, 10] + rnorm(n, 0., sigma2)
mX <- scale(mX)
vy <- (vy - mean(vy))
vy <- sqrt(n) * vy / sqrt(sum(vy ^ 2))
K <- 10
initial_gamma <- matrix(rbinom(K * p, 1, .5), K, p)
return(list(n=n, p=p, vy=vy, mX=mX, K=K, initial_gamma=initial_gamma))
}
data <- generate_data()
n <- data$n
p <- data$p
vy <- data$vy
mX <- data$mX
K <- data$K
initial_gamma <- data$initial_gamma
cva_result <- cva(initial_gamma, vy, mX, K)
corr_result <- correlation::all_correlations_mX(vy, mX)
binary_to_model <- function(binary_vec)
{
acc <- 0
mul <- 1
for (i in 1:length(binary_vec)) {
acc <- acc + mul * binary_vec[i]
mul <- mul * 2
}
return(acc)
}
log_p <- function(n, p, vR2, vp_gamma)
{
R2 <- R2[2:length(R2)]
p_gamma <- p_gamma[2:length(p_gamma)]
a <- 1
b <- p
return(-n / 2 * log(1 - R2) - p_gamma / 2 * log(n) + lbeta(a + p_gamma, b + p - p_gamma))
}
R2 <- corr_result$vR2
p_gamma <- corr_result$vp_gamma
cva_models <- apply(cva_result$models, 1, binary_to_model)
plot(log_p(n, p, R2, p_gamma), pch=21, xlab="Model Index", ylab="Posterior Model Probability", col="black", bg="black")
points(cva_models, log_p(n, p, R2, p_gamma)[cva_models], pch=21, col="red", bg="red")
plot_traj_probs <- function(cva_result)
{
traj_prob <- log(cva_result$trajectory_probs)
plot(1:ncol(traj_prob), traj_prob[1, ], ylim=c(min(traj_prob), max(traj_prob)), type="l",
xlab="Iteration", ylab="Posterior Probability")
for (k in 1:nrow(traj_prob)) {
lines(1:ncol(traj_prob), traj_prob[k, ])
}
}
plot_traj_probs(cva_result)
posterior_percentages <- function(K, lambda=1.)
{
n_sims <- 1e4
cva_results <- list()
global_mode <- rep(NA, n_sims)
posterior_percentage <- rep(NA, n_sims)
for (i in 1:n_sims) {
data <- generate_data()
n <- data$n
p <- data$p
vy <- data$vy
mX <- data$mX
K <- data$K
initial_gamma <- data$initial_gamma
cva_results[[i]] <- cva(initial_gamma, vy, mX, K, lambda=lambda)
corr_result <- correlation::all_correlations_mX(vy, mX)
R2 <- corr_result$vR2
p_gamma <- corr_result$vp_gamma
vp <- exp(log_p(n, p, R2, p_gamma))
cva_models <- apply(cva_results[[i]]$models, 1, binary_to_model)
global_mode[i] <- ifelse(any(cva_models == which.max(vp)), 1, 0)
posterior_percentage[i] <- sum(vp[cva_models])/sum(vp)
}
return(list(median_posterior_percentage=median(posterior_percentage),
mean_global_mode=mean(global_mode)))
}
for (K in c(20, 50, 100, 200)) {
for (lambda in 0:3) {
cat(K, lambda, "\n")
cat(str(posterior_percentages(K, lambda)), "\n")
}
}
vbeta_0 <- c(1.3, 0, 0, 1.3, 0, 0, 1.3, 0, 0, 1.3, 0, 0)
n <- 100
p <- length(vbeta_0)
mX <- matrix(rnorm(n * p), n, p)
vy <- mX %*% vbeta_0 + rnorm(n)
mX <- scale(mX)
vy <- (vy - mean(vy))
vy <- sqrt(n) * vy / sqrt(sum(vy ^ 2))
K <- 20
initial_gamma <- matrix(rbinom(K * p, 1, .5), K, p)
result <- cva(initial_gamma, vy, mX, K, lambda=10.)
v0=seq(0.1,1,by=0.1)
v1=1000
beta_init=rep(1,p)
a=b=1
epsilon=10^{-5}
library(EMVS)
result2 <- EMVS(vy,mX,v0=v0,v1=v1,type="betabinomial",beta_init=beta_init,sigma_init=1,epsilon=epsilon,a=a,b=b)
EMVSplot(result2,"both",FALSE)
EMVSbest(result2)
library(Matrix)
image(Matrix(result$models))
str(result2)
image(Matrix(result2$prob_inclusion))
library(correlation)
library(correlation)
library(Matrix)
library(EMVS)
set.seed(as.numeric(Sys.time()))
generate_data <- function()
{
n <- 50
p <- 21
sigma2 <- 1.
mX <- matrix(0, n, p)
mSigma_block <- matrix(c(1, .9, .9,
.9, 1, .9,
.9, .9, 1), 3, 3)
mSigma <- as.matrix(bdiag(mSigma_block, mSigma_block, mSigma_block,
mSigma_block, mSigma_block, mSigma_block,
mSigma_block))
chol_mSigma <- chol(mSigma)
for (i in 1:n) {
mX[i, ] <- t(chol_mSigma) %*% rnorm(p)
}
vy <- 1.3 * mX[, 1] + 13 * mX[, 4] + 1.3 * mX[, 7] + 1.3 * mX[, 10] + rnorm(n, 0., sigma2)
mX <- scale(mX)
vy <- (vy - mean(vy))
vy <- sqrt(n) * vy / sqrt(sum(vy ^ 2))
K <- 100
initial_gamma <- matrix(rbinom(K * p, 1, .5), K, p)
return(list(n=n, p=p, vy=vy, mX=mX, K=K, initial_gamma=initial_gamma))
}
data <- generate_data()
n <- data$n
p <- data$p
vy <- data$vy
mX <- data$mX
K <- data$K
initial_gamma <- data$initial_gamma
cva_result <- cva(initial_gamma, vy, mX, K)
corr_result <- correlation::all_correlations_mX(vy, mX)
v0=seq(0.1,1,by=0.1)
v1=1000
beta_init=rep(1,p)
a=b=1
epsilon=10^{-5}
EMVS_result=EMVS(vy,mX,v0=v0,v1=v1,type="betabinomial",beta_init=beta_init,sigma_init=1,epsilon=epsilon,a=a,b=b)
library(EMVS)
library(correlation)
library(Matrix)
library(EMVS)
set.seed(as.numeric(Sys.time()))
generate_data <- function()
{
n <- 50
p <- 21
sigma2 <- 1.
mX <- matrix(0, n, p)
mSigma_block <- matrix(c(1, .9, .9,
.9, 1, .9,
.9, .9, 1), 3, 3)
mSigma <- as.matrix(bdiag(mSigma_block, mSigma_block, mSigma_block,
mSigma_block, mSigma_block, mSigma_block,
mSigma_block))
chol_mSigma <- chol(mSigma)
for (i in 1:n) {
mX[i, ] <- t(chol_mSigma) %*% rnorm(p)
}
vy <- 1.3 * mX[, 1] + 13 * mX[, 4] + 1.3 * mX[, 7] + 1.3 * mX[, 10] + rnorm(n, 0., sigma2)
mX <- scale(mX)
vy <- (vy - mean(vy))
vy <- sqrt(n) * vy / sqrt(sum(vy ^ 2))
K <- 100
initial_gamma <- matrix(rbinom(K * p, 1, .5), K, p)
return(list(n=n, p=p, vy=vy, mX=mX, K=K, initial_gamma=initial_gamma))
}
data <- generate_data()
n <- data$n
p <- data$p
vy <- data$vy
mX <- data$mX
K <- data$K
initial_gamma <- data$initial_gamma
cva_result <- cva(initial_gamma, vy, mX, K)
corr_result <- correlation::all_correlations_mX(vy, mX)
v0=seq(0.1,1,by=0.1)
v1=1000
beta_init=rep(1,p)
a=b=1
epsilon=10^{-5}
EMVS_result=EMVS(vy,mX,v0=v0,v1=v1,type="betabinomial",beta_init=beta_init,sigma_init=1,epsilon=epsilon,a=a,b=b)
EMVSplot(EMVS_result,"both",FALSE)
v0=seq(0.001,0.2,by=0.005)
v1=1.0E3
beta_init=rep(1,p)
a=1
b=1
epsilon=1.0E-5
EMVS_result=EMVS(vy,mX,v0=v0,v1=v1,type="betabinomial",beta_init=beta_init,sigma_init=1,epsilon=epsilon,a=a,b=b)
EMVSplot(EMVS_result,"both",FALSE)
setwd("~/Downloads/")
?load
load("Owls.Rdata")
head(Owls)
View(Owls)
hist(Owls$SiblingNegotiation)
rm(Owls)
load("Epil2.Rdata")
View(epil2)
hist(epil2$y)
rm(epil2)
library(correlation)
library(Matrix)
library(EMVS)
set.seed(as.numeric(Sys.time()))
generate_data <- function()
{
n <- 50
p <- 21
sigma2 <- 1.
mX <- matrix(0, n, p)
mSigma_block <- matrix(c(1, .9, .9,
.9, 1, .9,
.9, .9, 1), 3, 3)
mSigma <- as.matrix(bdiag(mSigma_block, mSigma_block, mSigma_block,
mSigma_block, mSigma_block, mSigma_block,
mSigma_block))
chol_mSigma <- chol(mSigma)
for (i in 1:n) {
mX[i, ] <- t(chol_mSigma) %*% rnorm(p)
}
mX <- scale(mX)
vy <- 1.3 * mX[, 1] + 1.3 * mX[, 4] + 1.3 * mX[, 7] + 1.3 * mX[, 10] + rnorm(n, 0., sigma2)
vy <- (vy - mean(vy))
vy <- sqrt(n) * vy / sqrt(sum(vy ^ 2))
K <- 100
initial_gamma <- matrix(rbinom(K * p, 1, .5), K, p)
return(list(n=n, p=p, vy=vy, mX=mX, K=K, initial_gamma=initial_gamma))
}
data <- generate_data()
n <- data$n
p <- data$p
vy <- data$vy
mX <- data$mX
K <- data$K
initial_gamma <- data$initial_gamma
cva_result <- cva(initial_gamma, vy, mX, K)
corr_result <- correlation::all_correlations_mX(vy, mX)
v0=seq(0.001,0.2,by=0.005)
v1=1.0E3
beta_init=rep(1,p)
a=1
b=1
epsilon=1.0E-5
EMVS_result=EMVS(vy,mX,v0=v0,v1=v1,type="betabinomial",beta_init=beta_init,sigma_init=1,epsilon=epsilon,a=a,b=b)
EMVSplot(EMVS_result,"both",FALSE)
EMVSbest(EMVS_result)
EMVSsummary(EMVS_result)
binary_to_model <- function(binary_vec)
{
acc <- 0
mul <- 1
for (i in 1:length(binary_vec)) {
acc <- acc + mul * binary_vec[i]
mul <- mul * 2
}
return(acc)
}
log_p <- function(n, p, vR2, vp_gamma)
{
R2 <- R2[2:length(R2)]
p_gamma <- p_gamma[2:length(p_gamma)]
a <- 1
b <- p
return(-n / 2 * log(1 - R2) - p_gamma / 2 * log(n) + lbeta(a + p_gamma, b + p - p_gamma))
}
R2 <- corr_result$vR2
p_gamma <- corr_result$vp_gamma
cva_models <- apply(cva_result$models, 1, binary_to_model)
plot(log_p(n, p, R2, p_gamma), pch=21, xlab="Model Index", ylab="Posterior Model Probability", col="black", bg="black")
points(cva_models, log_p(n, p, R2, p_gamma)[cva_models], pch=21, col="red", bg="red")
vlog_p <- exp(log_p(n, p, R2, p_gamma))
x <- diff(vlog_p)
n <- length(x)
par(mfrow=c(1, 1))
plot(log_p(n, p, R2, p_gamma), pch=21, xlab="Model Index", ylab="Posterior Model Probability", col="black", bg="black")
points(cva_models, log_p(n, p, R2, p_gamma)[cva_models], pch=21, col="red", bg="red")
library(correlation)
library(Matrix)
library(EMVS)
set.seed(as.numeric(Sys.time()))
generate_data <- function()
{
n <- 50
p <- 21
sigma2 <- 1.
mX <- matrix(0, n, p)
mSigma_block <- matrix(c(1, .9, .9,
.9, 1, .9,
.9, .9, 1), 3, 3)
mSigma <- as.matrix(bdiag(mSigma_block, mSigma_block, mSigma_block,
mSigma_block, mSigma_block, mSigma_block,
mSigma_block))
chol_mSigma <- chol(mSigma)
for (i in 1:n) {
mX[i, ] <- t(chol_mSigma) %*% rnorm(p)
}
mX <- scale(mX)
vy <- 1.3 * mX[, 1] + 1.3 * mX[, 4] + 1.3 * mX[, 7] + 1.3 * mX[, 10] + rnorm(n, 0., sigma2)
vy <- (vy - mean(vy))
vy <- sqrt(n) * vy / sqrt(sum(vy ^ 2))
K <- 100
initial_gamma <- matrix(rbinom(K * p, 1, .5), K, p)
return(list(n=n, p=p, vy=vy, mX=mX, K=K, initial_gamma=initial_gamma))
}
data <- generate_data()
n <- data$n
p <- data$p
vy <- data$vy
mX <- data$mX
K <- data$K
initial_gamma <- data$initial_gamma
cva_result <- cva(initial_gamma, vy, mX, K)
corr_result <- correlation::all_correlations_mX(vy, mX)
v0=seq(0.001,0.2,by=0.005)
v1=1.0E3
beta_init=rep(1,p)
a=1
b=1
epsilon=1.0E-5
EMVS_result=EMVS(vy,mX,v0=v0,v1=v1,type="betabinomial",beta_init=beta_init,sigma_init=1,epsilon=epsilon,a=a,b=b)
EMVSplot(EMVS_result,"both",FALSE)
EMVSbest(EMVS_result)
EMVSsummary(EMVS_result)
binary_to_model <- function(binary_vec)
{
acc <- 0
mul <- 1
for (i in 1:length(binary_vec)) {
acc <- acc + mul * binary_vec[i]
mul <- mul * 2
}
return(acc)
}
log_p <- function(n, p, vR2, vp_gamma)
{
R2 <- R2[2:length(R2)]
p_gamma <- p_gamma[2:length(p_gamma)]
a <- 1
b <- p
return(-n / 2 * log(1 - R2) - p_gamma / 2 * log(n) + lbeta(a + p_gamma, b + p - p_gamma))
}
R2 <- corr_result$vR2
p_gamma <- corr_result$vp_gamma
cva_models <- apply(cva_result$models, 1, binary_to_model)
plot(log_p(n, p, R2, p_gamma), pch=21, xlab="Model Index", ylab="Posterior Model Probability", col="black", bg="black")
points(cva_models, log_p(n, p, R2, p_gamma)[cva_models], pch=21, col="red", bg="red")
library(correlation)
library(correlation)
dataset <- "BodyFat"
print(dataset)
dat  = read.table(file="bodyfat.txt",header=TRUE)
s.i  = c(39,42,48,96,76,182,31,86)
dat2 = dat[-s.i,-1]
dat2$Weight  = round(0.45359237*dat2$Weight,2) # convert lbs into kg
y.t <- as.vector(dat2$Bodyfat)
X.f <- as.matrix(dat2[,-1]) # note: includes intercept
n <- nrow(X.f)
p <- ncol(X.f)
mu.y      <- mean( y.t )
sigma2.y  <- (n-1)*var(y.t)/n
y.n <- (y.t - mu.y)/sqrt(sigma2.y)
X.n <- matrix(0,n,p)
mu.x <- c()
sigma2.x <- c()
for (j in 1:p)
{
mu.x[j]      <- mean( X.f[,j] )
sigma2.x[j]  <- (n-1)*var(X.f[,j])/n
X.n[,j] <- (X.f[,j] - mu.x[j])/sqrt(sigma2.x[j])
}
library(correlation)
vy = y.n
mX = X.n
vR2 <- correlation::all_correlations_mX(vy, mX)
mGamma = graycode(p,0)
vq = mGamma%*%matrix(1,p,1)
M = nrow(mGamma)
XTy = t(mX)%*%vy
XTX = t(mX)%*%mX
verr = c()
for (i in 1:1000) {
inds = which(mGamma[i,]==1)
if (length(inds)>2) {
R2 = t(XTy[inds])%*%solve(XTX[inds,inds])%*%XTy[inds]/n
verr <- c(verr,abs(R2-vR2[i]))
#cat(i,R2,vR2[i],abs(R2-vR2[i]),"\n")
}
}
vR2 <- correlation::all_correlations_mX(vy, mX)$vR2
mGamma = graycode(p,0)
vq = mGamma%*%matrix(1,p,1)
M = nrow(mGamma)
XTy = t(mX)%*%vy
XTX = t(mX)%*%mX
verr = c()
for (i in 1:1000) {
inds = which(mGamma[i,]==1)
if (length(inds)>2) {
R2 = t(XTy[inds])%*%solve(XTX[inds,inds])%*%XTy[inds]/n
verr <- c(verr,abs(R2-vR2[i]))
#cat(i,R2,vR2[i],abs(R2-vR2[i]),"\n")
}
}
print("The maximum error is:")
print(max(verr))
vBIC = n*log(1 - vR2) + vq*log(n)
a  = -0.75
vb = 0.5*(n - vq - 5) - a
c  = 0.5*(n - 1)
vd = 0.5*vq + a
log.vp.ZE = -(vb+1)*log(1 - vR2) + lbeta(vd+1,vb+1) - lbeta(a+1,vb+1)
vZE <- -2*log.vp.ZE
model.post.ZE <- exp(log.vp.ZE - max(log.vp.ZE))/sum(exp(log.vp.ZE - max(log.vp.ZE)))
ord = order(log.vp.ZE,decreasing=TRUE)
TOPMODELS = 20
best = which.min(vZE)
tab = cbind( mGamma, model.post.ZE,   vZE - vZE[best], vBIC - vBIC[best]  )[ord[1:TOPMODELS],]
var.post.ZE <- t(mGamma)%*%model.post.ZE
print(tab)
print(var.post.ZE)
tab = cbind( mGamma, model.post.ZE,   vR2, vZE - vZE[best], vBIC - vBIC[best]  )[ord[1:TOPMODELS],]
print(tab)
t(XTy[ord[1]])%*%solve(XTX[ord[1], ord[1]])%*%XTy[ord[1]]/n
t(XTy[c(2, 6, 13)])%*%solve(XTX[c(2, 6, 13), c(2, 6, 13)])%*%XTy[c(2, 6, 13)]/n
