% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{cva}
\alias{cva}
\title{Run a Collapsed Variational Approximation to find the K best linear models}
\usage{
cva(gamma_initial, vy_in, mX_in, K, lambda = 1, prior = "maruyama",
  bUnique = TRUE)
}
\arguments{
\item{gamma_initial}{Matrix of initial models, a K by p logical matrix}

\item{K}{The number of particles in the population}

\item{lambda}{The weighting factor for the entropy in f_lambda. Defaults to 1.}

\item{prior}{The prior to use. The choices of prior available are "maruyama", "BIC", "ZE",
"liang_g1", "liang_g2", "liang_g_n_appell", "liang_g_approx", "liang_g_n_quad",
"robust_bayarri1" and "robust_bayarri2"}

\item{bUnique}{Whether to ensure uniqueness in the population of particles or not. Defaults to true.}

\item{vy}{Vector of responses}

\item{mX}{Matrix of covariates}
}
\value{
A list containing the named element models, which is a K by p matrix of the models
				selected by the algorithm, and the named element trajectory, which includes a list
				of the populations of models for each iteration of the algorithm until it converged
}
\description{
Run a Collapsed Variational Approximation to find the K best linear models
}
\examples{
library(MASS)

mD <- UScrime
notlog <- c(2,ncol(UScrime))
mD[,-notlog] <- log(mD[,-notlog])

for (j in 1:ncol(mD)) {
  mD[,j] <- (mD[,j] - mean(mD[,j]))/sd(mD[,j])
}

varnames <- c(
  "log(AGE)",
  "S",
  "log(ED)",
  "log(Ex0)",
  "log(Ex1)",
  "log(LF)",
  "log(M)",
  "log(N)",
  "log(NW)",
  "log(U1)",
  "log(U2)",
  "log(W)",
  "log(X)",
  "log(prison)",
  "log(time)")

y.t <- mD$y
X.f <- data.matrix(cbind(mD[1:15]))
colnames(X.f) <- varnames 
K <- 100
p <- ncol(X.f)
initial_gamma <- matrix(rbinom(K * p, 1, .5), K, p)
cva_result <- cva(initial_gamma, y.t, X.f, K, lambda = 1.0, prior = "maruyama")
> str(cva_result)
List of 3
 $ models          : num [1:100, 1:15] 1 0 0 0 0 0 0 0 0 1 ...
 $ trajectory      :List of 6
  ..$ : num [1:100, 1:15] 1 0 1 1 0 1 1 0 0 1 ...
  ..$ : num [1:100, 1:15] 1 0 0 0 1 1 0 0 0 0 ...
  ..$ : num [1:100, 1:15] 1 0 0 0 0 0 0 0 0 1 ...
  ..$ : num [1:100, 1:15] 1 0 0 0 0 0 0 0 0 1 ...
  ..$ : num [1:100, 1:15] 1 0 0 0 0 0 0 0 0 1 ...
  ..$ : num [1:100, 1:15] 1 0 0 0 0 0 0 0 0 1 ...
 $ trajectory_probs: num [1:100, 1:6] 4.20e-07 1.74e-06 4.77e-12 2.80e-13 1.02e-05 ...
}
